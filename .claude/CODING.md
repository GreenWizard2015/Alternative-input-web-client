# Coding Style Guide

## Naming Conventions

| Category | Pattern | Example |
|----------|---------|---------|
| Variables/functions | camelCase | `selectedCameras`, `handleDataWorkerReady` |
| Components/Classes | PascalCase | `FaceDetectorComponent`, `CameraFrameCaptureController` |
| Constants | UPPERCASE_SNAKE_CASE | `READINESS_TIMEOUT`, `DEFAULT_SETTINGS` |
| Type/Interface names | PascalCase | `DetectionResult`, `WorkerConfig` |
| Private/internal | underscore prefix | `_circleROI`, `_toGrayscale` |
| Callbacks | `on` or `handle` prefix | `onDetect`, `handleFrame` |
| Redux slices | Interface with `I` | `IScreen`, `ICamera` |
| File names | Component: PascalCase, Utils: camelCase | `FaceDetector.tsx`, `faceDetectorHelpers.ts` |
| Workers | `.worker.ts` suffix | `FaceDetector.worker.ts` |

## File Structure

```typescript
// 1. Imports (external, then internal)
import React, { useCallback } from 'react';
import { hash128Hex } from '../utils';
import type { Position } from '../shared/Sample';

// 2. Constants
const READINESS_TIMEOUT = 3000;
const DEFAULT_SETTINGS = { /* ... */ };

// 3. Types/Interfaces
interface Props { /* ... */ }
type DetectionResult = { /* ... */ }

// 4. Main component/function/class
export function MyComponent(props: Props) { /* ... */ }

// 5. Exports
export default MyComponent;
```

## TypeScript Patterns

- **Explicit annotations** on function parameters and returns
- **Use `type`** for unions, simple aliases: `type Position = { x: number; y: number }`
- **Use `interface`** for complex objects needing extension
- **Typed refs**: `useRef<HTMLVideoElement | null>(null)`
- **Typed Maps**: `new Map<string, WorkerStats>()`
- **Avoid `any`** — import proper types instead

## React Patterns

- **Functional components only** with hooks
- **Props destructured** with explicit typing: `function Component({ prop1, prop2 }: Props)`
- **Multiple effects** for separate concerns, not one large effect
- **Refs for objects** that shouldn't trigger re-renders (managers, workers)
- **useCallback** for event handlers passed to other components — wrap with dependencies
- **Redux**: Use selectors and `connect()` HOC, destructure props
- **Dependencies** explicitly listed in useEffect deps array
- **Double-check effect dependencies**: Are all values used in effect included? Are unnecessary deps causing extra runs?
  - ✅ `useEffect(() => { foo(); }, [foo])` — foo is stable/memoized
  - ❌ `useEffect(() => { foo(bar); }, [foo])` — missing bar, stale closure
  - ❌ `useEffect(() => { setValue(state => state.count); }, [])` — works but check for unintended behavior
- **useCallback best practices**:
  - ✅ Memoize callbacks passed to child components to prevent child re-renders
  - ✅ Include all dependencies: `useCallback((x) => handler(x, dep), [dep])`
  - ❌ Don't memoize callbacks only used locally — overhead > benefit
  - ❌ Missing dependencies causes stale closures: `useCallback(() => use(prop), [])`
  - ❌ Too many deps defeats purpose: `useCallback(fn, [dep1, dep2, dep3, ...])`

## Error Handling

- **Validation in constructors** with throw for data integrity
- **try-catch** for async operations with detailed error messages
- **Graceful degradation**: Log and continue when possible
- **Error context**: `[ComponentName] Description: ${error.message}`
- **Null checks**: Explicit before operations — `if (!instance) return`
- **Optional chaining**: `obj?.property?.value`
- **Nullish coalescing**: `value ?? defaultValue`

## Code Organization

- **Section dividers**: `// ===== SectionName =====`
- **Sections**: Constants → Types → Helpers → Hooks → Main → Exports
- **One concern per file** — extract helpers to separate files
- **Comments above** non-obvious logic (explain *why*, not *what*)
- **JSDoc headers** on files explaining purpose

## Constants & Config

- **UPPERCASE_SNAKE_CASE** for all constants
- **Extract magic numbers** to named constants
- **Settings objects**: Use spread pattern `{ ...DEFAULT, override: value }`
- **Local constants** in files where used; shared in utility files

## Resource Management

- **Explicit cleanup** functions for streams, workers, intervals
- **useEffect return** cleanup functions for unmount
- **Track resources** in Maps/Sets (workers, controllers, streams)
- **Idempotent cleanup** — safe to call multiple times
- **Close/stop resources** when done: `frame.close()`, `stream.stop()`, `worker.terminate()`

## Redux Patterns

- **Slices** with actions and reducers co-located
- **Selectors** extracted to `selectors.ts` and memoized
- **mapStateToProps** extracting only needed selectors
- **Typed state**: `state: RootState` not `state: any`
- **Action types** auto-generated by createSlice
- **Complex state as JSON**: Store nested objects/arrays as JSON strings in Redux to prevent re-renders. Only parse to objects in selectors when needed.
  - ✅ `configJson: '{"key":"value"}'` → parse in selector → memoized comparison on string
  - ❌ `config: { key: "value" }` → object identity changes → memoization fails, re-renders cascade
  - Example: `export const selectConfig = (state) => JSON.parse(state.app.configJson)`

## What to Avoid

- ❌ `any` types — use proper imports
- ❌ Complex single effects — split into multiple
- ❌ Magic numbers — extract to constants
- ❌ Inline types in component props — use separate type definitions
- ❌ Large single files — extract helpers/utils
- ❌ Silent failures — log or throw errors with context
- ❌ Mutable default parameters — use destructuring with defaults
