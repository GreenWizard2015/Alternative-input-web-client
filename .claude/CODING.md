# Coding Style Guide

## Naming Conventions

| Category | Pattern | Example |
|----------|---------|---------|
| Variables/functions | camelCase | `selectedCameras`, `handleDataWorkerReady` |
| Components/Classes | PascalCase | `FaceDetectorComponent`, `CameraFrameCaptureController` |
| Constants | UPPERCASE_SNAKE_CASE | `READINESS_TIMEOUT`, `DEFAULT_SETTINGS` |
| Type/Interface names | PascalCase | `DetectionResult`, `WorkerConfig` |
| Private/internal | underscore prefix | `_circleROI`, `_toGrayscale` |
| Callbacks | `on` or `handle` prefix | `onDetect`, `handleFrame` |
| Redux slices | Interface with `I` | `IScreen`, `ICamera` |
| File names | Component: PascalCase, Utils: camelCase | `FaceDetector.tsx`, `faceDetectorHelpers.ts` |
| Workers | `.worker.ts` suffix | `FaceDetector.worker.ts` |

## File Structure

```typescript
// 1. Imports (external, then internal)
import React, { useCallback } from 'react';
import { hash128Hex } from '../utils';
import type { Position } from '../shared/Sample';

// 2. Constants
const READINESS_TIMEOUT = 3000;
const DEFAULT_SETTINGS = { /* ... */ };

// 3. Types/Interfaces
interface Props { /* ... */ }
type DetectionResult = { /* ... */ }

// 4. Main component/function/class
export function MyComponent(props: Props) { /* ... */ }

// 5. Exports
export default MyComponent;
```

## TypeScript Patterns

- **Explicit annotations** on function parameters and returns
- **Use `type`** for unions, simple aliases: `type Position = { x: number; y: number }`
- **Use `interface`** for complex objects needing extension
- **Typed refs**: `useRef<HTMLVideoElement | null>(null)`
- **Typed Maps**: `new Map<string, WorkerStats>()`
- **Avoid `any`** — import proper types instead

## React Patterns

- **Functional components only** with hooks
- **Props destructured** with explicit typing: `function Component({ prop1, prop2 }: Props)`
- **Multiple effects** for separate concerns, not one large effect
- **Refs for objects** that shouldn't trigger re-renders (managers, workers)
- **useCallback** for event handlers passed to other components — wrap with dependencies
- **Redux**: Use selectors and `connect()` HOC, destructure props
- **Dependencies** explicitly listed in useEffect deps array
- **Double-check effect dependencies**: Are all values used in effect included? Are unnecessary deps causing extra runs?
  - ✅ `useEffect(() => { foo(); }, [foo])` — foo is stable/memoized
  - ❌ `useEffect(() => { foo(bar); }, [foo])` — missing bar, stale closure
  - ❌ `useEffect(() => { setValue(state => state.count); }, [])` — works but check for unintended behavior
- **useCallback best practices**:
  - ✅ Memoize callbacks passed to child components to prevent child re-renders
  - ✅ Include all dependencies: `useCallback((x) => handler(x, dep), [dep])`
  - ❌ Don't memoize callbacks only used locally — overhead > benefit
  - ❌ Missing dependencies causes stale closures: `useCallback(() => use(prop), [])`
  - ❌ Too many deps defeats purpose: `useCallback(fn, [dep1, dep2, dep3, ...])`

## Error Handling

- **Validation in constructors** with throw for data integrity
- **try-catch** for async operations with detailed error messages
- **Graceful degradation**: Log and continue when possible
- **Error context**: `[ComponentName] Description: ${error.message}`
- **Null checks**: Explicit before operations — `if (!instance) return`
- **Optional chaining**: `obj?.property?.value`
- **Nullish coalescing**: `value ?? defaultValue`

## Code Organization

- **Section dividers**: Only for complex files with many sections
- **Sections**: Constants → Types → Helpers → Hooks → Main → Exports
- **One concern per file** — extract helpers to separate files
- **Comments above** non-obvious logic (explain *why*, not *what*)
- **JSDoc headers** on files explaining purpose
- **Avoid obvious comments** — "Fresh controller for this session" is noise if code is clear

## Constants & Config

- **UPPERCASE_SNAKE_CASE** for all constants
- **Extract magic numbers** to named constants
- **Settings objects**: Use spread pattern `{ ...DEFAULT, override: value }`
- **Local constants** in files where used; shared in utility files

## Resource Management

- **Explicit cleanup** functions for streams, workers, intervals
- **useEffect return** cleanup functions for unmount
- **Track resources** in Maps/Sets (workers, controllers, streams)
- **Idempotent cleanup** — safe to call multiple times
- **Close/stop resources** when done: `frame.close()`, `stream.stop()`, `worker.terminate()`

## Redux Patterns

- **Slices** with actions and reducers co-located
- **Selectors** extracted to `selectors.ts` and memoized
- **mapStateToProps** extracting only needed selectors
- **Typed state**: `state: RootState` not `state: any`
- **Action types** auto-generated by createSlice
- **Always use `connect()` HOC** (not useSelector/useDispatch hooks) for Redux integration
- **Inline `connect()` mappers**: For simple cases, inline mapStateToProps and mapDispatchToProps directly in `connect()` to reduce boilerplate
  - ✅ `connect((state: RootState) => ({ value: selector(state) }), { action })(Component)`
  - ❌ useSelector/useDispatch hooks — use `connect()` instead
  - ❌ Separate named functions when mappers have complex logic — keep file readable
- **Complex state as JSON**: Store nested objects/arrays as JSON strings in Redux to prevent re-renders. Only parse to objects in selectors when needed.
  - ✅ `configJson: '{"key":"value"}'` → parse in selector → memoized comparison on string
  - ❌ `config: { key: "value" }` → object identity changes → memoization fails, re-renders cascade
  - Example: `export const selectConfig = (state) => JSON.parse(state.app.configJson)`

## What to Avoid

- ❌ `any` types — use proper imports
- ❌ Complex single effects — split into multiple
- ❌ Magic numbers — extract to constants
- ❌ Inline types in component props — use separate type definitions
- ❌ Large single files — extract helpers/utils
- ❌ Silent failures — log or throw errors with context
- ❌ Mutable default parameters — use destructuring with defaults

## React State & Callbacks Anti-Pattern: Setting Functions Directly

### Problem
When storing a callback function in React state, **always wrap it in a setter function**. Setting it directly causes React to treat it as a state initializer, not the actual value.

```typescript
// ❌ WRONG - React treats this as a state initializer function
setCallback(onConfirm);  // onConfirm gets called, its return value becomes state

// ✅ CORRECT - Wrap in arrow function to store the callback itself
setCallback(() => onConfirm);  // Callback is stored as state value
```

### Why This Matters
React's `setState` has special handling: if you pass a function, it assumes it's an initializer and calls it to get the initial state. This caused `onGameStartConfirm` to always be `false` (the return value of a function).

### Real Example (Fixed in this project)
In `useDialogStateMachine.ts`, the game confirmation dialog callback wasn't rendering:

```typescript
// ❌ ORIGINAL - Callback never stored
const openGameConfirmDialog = useCallback((gameMode, onConfirm) => {
  setPendingGameMode(gameMode);
  setOnGameStartConfirm(onConfirm);  // React treats onConfirm as initializer!
  dispatch(openGameConfirmDialogAction());
}, [dispatch]);

// ✅ FIXED - Wrap callback in setter function
const openGameConfirmDialog = useCallback((gameMode, onConfirm) => {
  setPendingGameMode(gameMode);
  setOnGameStartConfirm(() => onConfirm);  // Wraps callback so it's stored as value
  dispatch(openGameConfirmDialogAction());
}, [dispatch]);
```

### Debugging Tip
When state containing functions is `undefined` or `null` unexpectedly, suspect this pattern. Add logs:

```typescript
useEffect(() => {
  console.log('[Hook] onGameStartConfirm:', !!onGameStartConfirm);
  if (onGameStartConfirm) {
    console.log('[Hook] Callback:', onGameStartConfirm.toString());
  }
}, [onGameStartConfirm]);
```

This will reveal if the state is never being set (always `false`/`null`) despite calling the setter.
